/***************************************************************************************
 * Proyecto: Rulit Test - Endpoint y Automatización de Formulario (Google Sheets & Forms)
 * Archivo: main.gs
 * Plataforma: Google Apps Script (Sheets + Forms + Mail)
 *
 * Descripción:
 *   - Publica un endpoint web (doGet) que muestra una página de instrucciones y abre la app.
 *   - Escucha envíos de Google Forms (onFormSubmit), guarda un ID de respuesta en Sheets
 *     y envía un correo de confirmación al respondente (con copia opcional al admin).
 *   - Incluye utilidades para crear/borrar triggers de forma segura.
 *
 * Recomendado:
 *   - Vincular este proyecto a la HOJA de cálculo de respuestas del Form (Extensions → Apps Script).
 *   - Implementar despliegue como app web (Deploy → New deployment → Web app).
 *
 * NOTA IMPORTANTE:
 *   - Este código está DOCUMENTADO línea a línea para facilitar su mantenimiento.
 ***************************************************************************************/

/** ============================== CONFIGURACIÓN GLOBAL ============================== **/

/**
 * ID del Formulario que dispara el trigger de envío.
 * Reemplaza por tu propio ID si difiere.
 */
const CFG_FORM_ID = '1p3JevHmpbzqwH6OA72lVPY091mK1JrXqIGbmvpbvOXk';

/**
 * ID de la Hoja de cálculo donde se registran las respuestas del Form.
 * Debe ser la hoja con las respuestas (o donde quieras escribir el "ID de Respuesta").
 */
const CFG_SHEET_ID = '1p4O9wyrhegS8PiHDsmo_aofEuimeQx9ngZxU2wezkVE';

/**
 * Nombre de la columna donde se guardará el ID único de la respuesta del Form.
 * Si no existe, se creará automáticamente.
 */
const CFG_RESPONSE_ID_HEADER = 'ID de Respuesta';

/**
 * URL base de la app (front) a la que se redirige al usuario desde el botón "Comenzar Test".
 * Debe aceptar como sufijo el rowId (ID de respuesta del Form) codificado.
 */
const CFG_APP_URL = 'https://investigar-webapp.web.app/rulit/appscript-callback/';

/**
 * URL base del endpoint Apps Script publicado como "Web app" (doGet).
 * Úsala para generar enlaces profundos que incluyan el parámetro rowId.
 * Reemplaza por la URL de despliegue de tu propio proyecto cuando lo publiques.
 */
const CFG_EXEC_URL_BASE = 'https://script.google.com/macros/s/AKfycbxbkgrY8cIF2DCY8ggI4kuCmkzDFf3F8thbtEJya_p3HRKq3pqPaVtXiSz76_xQJVGr/exec';

/**
 * Dirección de correo del administrador (para copia/seguimiento).
 * Dejar vacío ("") si no deseas enviar copia.
 */
const CFG_ADMIN_EMAIL = 'rodrig.florencia@gmail.com';

/**
 * Título usado en la página HTML de instrucciones (doGet).
 */
const CFG_HTML_TITLE = 'Instrucciones del Test';

/** ============================== ENDPOINT WEB (GET) =============================== **/

/**
 * Endpoint público (Web App) que genera una página HTML con instrucciones y un botón
 * para abrir la app principal pasando el rowId como parámetro.
 *
 * Ejemplo de URL:
 *   <EXEC_URL>?rowId=RESPUESTA_123
 *
 * @param {GoogleAppsScript.Events.DoGet} e - Parámetros de la llamada (puede incluir ?rowId=...)
 * @returns {GoogleAppsScript.HTML.HtmlOutput} - Página HTML renderizada.
 */
function doGet(e) {
  // ---------------------------------------------------------------------------------
  // 1) Obtención segura del parámetro rowId (si no viene, se deja vacío para fallback).
  // ---------------------------------------------------------------------------------
  const rowId = (() => {
    try {
      // Asegura que e.parameters exista y que rowId sea array [..]
      if (e && e.parameters && e.parameters.rowId && e.parameters.rowId[0]) {
        return String(e.parameters.rowId[0]).trim();
      }
    } catch (err) {
      console.error('No se pudo leer el parámetro rowId:', err);
    }
    return ''; // Fallback: vacío
  })();

  // ---------------------------------------------------------------------------------
  // 2) Construcción de URL de la app (front) con rowId codificado cuando exista.
  // ---------------------------------------------------------------------------------
  const appLaunchUrl = rowId ? (CFG_APP_URL + encodeURIComponent(rowId)) : CFG_APP_URL;

  // ---------------------------------------------------------------------------------
  // 3) Construcción del HTML mediante plantilla utilitaria (ver utils.gs).
  // ---------------------------------------------------------------------------------
  const html = Templates.buildInstructionHtml({
    pageTitle: CFG_HTML_TITLE,
    primaryButtonText: 'Comenzar Test',
    appUrl: appLaunchUrl
  });

  // ---------------------------------------------------------------------------------
  // 4) Configurar el HtmlOutput (título, sandbox, tamaño).
  // ---------------------------------------------------------------------------------
  const out = HtmlService.createHtmlOutput(html)
    .setTitle(CFG_HTML_TITLE)                     // Título de la ventana
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL); // Permite IFRAME si se requiere

  return out;
}

/** ============================== EVENTO: ENVÍO DE FORM ============================ **/

/**
 * Controlador de evento para envíos de Google Forms.
 *  - Toma el ID de la respuesta y el timestamp.
 *  - Asegura la existencia de la columna "ID de Respuesta" en la hoja.
 *  - Localiza la fila por timestamp (exact match) y escribe el ID de respuesta.
 *  - Envía un correo de confirmación al respondente (si se obtuvo su email).
 *
 * Requisitos:
 *  - Debe existir un trigger instalable "On form submit" apuntando a esta función.
 *
 * @param {GoogleAppsScript.Events.FormsOnFormSubmit} e - Evento de envío del Form.
 * @returns {Object} - Resumen del resultado (útil para logs o testing).
 */
function onFormSubmit(e) {
  try {
    // ------------------------------------------------------------------------------
    // 1) Validaciones de entrada (asegúrate de que el evento tenga la estructura).
    // ------------------------------------------------------------------------------
    if (!e || !e.response) {
      throw new Error('Evento inválido: falta e.response');
    }

    // ------------------------------------------------------------------------------
    // 2) Metadatos del envío (ID único y timestamp del Form).
    // ------------------------------------------------------------------------------
    const formResponse = e.response;
    const responseId = formResponse.getId();            // ID único de la respuesta
    const timestamp = formResponse.getTimestamp();      // Fecha/hora de envío (Date)
    const tz = Session.getScriptTimeZone() || 'UTC';    // Zona horaria del script

    // ------------------------------------------------------------------------------
    // 3) Apertura de la hoja de respuestas y lectura de cabeceras.
    // ------------------------------------------------------------------------------
    const ss = SpreadsheetApp.openById(CFG_SHEET_ID);   // Abre por ID
    const sheet = ss.getSheets()[0];                    // Primera hoja (ajusta si necesitas otra)
    const lastRow = sheet.getLastRow();                 // Última fila con datos
    const lastCol = sheet.getLastColumn();              // Última columna con datos

    // Si la hoja está vacía o sólo tiene headers, preparar cabeceras de forma segura.
    const headers = (lastCol > 0)
      ? (sheet.getRange(1, 1, 1, lastCol).getValues()[0] || [])
      : [];

    // ------------------------------------------------------------------------------
    // 4) Garantizar que exista la columna "ID de Respuesta".
    // ------------------------------------------------------------------------------
    let idColIndex = headers.indexOf(CFG_RESPONSE_ID_HEADER) + 1; // 1-based
    if (idColIndex === 0) {
      // No existe la columna → crear una nueva al final.
      idColIndex = Math.max(1, lastCol + 1);
      sheet.getRange(1, idColIndex).setValue(CFG_RESPONSE_ID_HEADER);
    }

    // ------------------------------------------------------------------------------
    // 5) Buscar la fila por coincidencia exacta de timestamp.
    //    Se compara en milisegundos para evitar problemas de formato.
    // ------------------------------------------------------------------------------
    if (lastRow > 1) {
      const timestamps = sheet.getRange(2, 1, lastRow - 1, 1).getValues().map(r => r[0]); // Col A
      const targetMs = timestamp.getTime();
      const foundIndex = timestamps.findIndex(t => {
        try {
          return new Date(t).getTime() === targetMs;
        } catch (_err) {
          return false;
        }
      });

      if (foundIndex !== -1) {
        // La fila real es offset + header
        const targetRow = foundIndex + 2;
        sheet.getRange(targetRow, idColIndex).setValue(responseId);
      } else {
        // Si no se encontró por timestamp, opcionalmente se puede anexar abajo.
        const appendRow = lastRow + 1;
        sheet.getRange(appendRow, 1).setValue(timestamp);           // Timestamp en Col A
        sheet.getRange(appendRow, idColIndex).setValue(responseId); // ID en su columna
      }
    } else {
      // Hoja sin datos → escribir headers mínimos y la primer fila.
      sheet.getRange(1, 1).setValue('Marca temporal');
      sheet.getRange(1, idColIndex).setValue(CFG_RESPONSE_ID_HEADER);
      sheet.getRange(2, 1).setValue(timestamp);
      sheet.getRange(2, idColIndex).setValue(responseId);
    }

    // ------------------------------------------------------------------------------
    // 6) Envío de correo de confirmación.
    //    - Usa el correo del respondente si se recopila en el Form.
    // ------------------------------------------------------------------------------
    const respondentEmail = safeGetRespondentEmail(e); // Ver utils.gs
    const prettyTs = Utilities.formatDate(timestamp, tz, "yyyy-MM-dd HH:mm:ss z");

    // Construye URL profunda a doGet con el rowId=ID de respuesta
    const deepLink = buildExecDeepLink(responseId); // Ver utils.gs

    if (respondentEmail) {
      // Contenido del correo (HTML)
      const subject = 'Confirmación de tu respuesta al formulario';
      const htmlBody = EmailTemplates.buildConfirmationHtml({
        responseId: responseId,
        timestampStr: prettyTs,
        deepLink: deepLink
      });

      // Opcional: BCC al admin si está configurado
      const mailOptions = {
        htmlBody: htmlBody
      };
      if (CFG_ADMIN_EMAIL && CFG_ADMIN_EMAIL.trim() !== '') {
        mailOptions.bcc = CFG_ADMIN_EMAIL;
      }

      // Enviar al respondente
      MailApp.sendEmail(respondentEmail, subject, 'Tu cliente de correo no soporta HTML.', mailOptions);
      console.log(`✅ Correo enviado a: ${respondentEmail}`);
    } else {
      console.warn('⚠️ No se obtuvo correo del respondente. Verifica configuración del Form.');
      // Opcional: Notificar al admin cuando no hay email del respondente
      if (CFG_ADMIN_EMAIL && CFG_ADMIN_EMAIL.trim() !== '') {
        MailApp.sendEmail(
          CFG_ADMIN_EMAIL,
          '[Rulit] Respuesta sin email de respondente',
          `No se encontró email para el responseId=${responseId} - ${prettyTs}\nDeepLink: ${deepLink}`
        );
      }
    }

    // ------------------------------------------------------------------------------
    // 7) Resumen de la ejecución (dev-friendly).
    // ------------------------------------------------------------------------------
    return {
      status: 'success',
      responseId: responseId,
      emailSentTo: respondentEmail || null,
      deepLink: deepLink
    };
  } catch (error) {
    console.error('❌ Error en onFormSubmit:', error);
    return { status: 'error', message: String(error) };
  }
}

/** ============================== TRIGGERS (INSTALABLES) =========================== **/

/**
 * Crea (solo si falta) un trigger instalable "On form submit" para este proyecto.
 * Evita duplicados eliminando previamente otros triggers con el mismo handler.
 */
function setupFormSubmitTrigger() {
  // Elimina triggers previos del mismo handler para evitar duplicados.
  Triggers.deleteByHandler('onFormSubmit');

  try {
    const form = FormApp.openById(CFG_FORM_ID);
    ScriptApp.newTrigger('onFormSubmit')
      .forForm(form)
      .onFormSubmit()
      .create();

    console.log(`✅ Trigger instalado para el Form: ${form.getTitle()}`);
    return 'Trigger configurado correctamente';
  } catch (error) {
    console.error('❌ Error al configurar el trigger:', error);
    throw error;
  }
}

/**
 * Crea un trigger para el Form ACTIVO en el editor (alternativa a CFG_FORM_ID).
 * Útil cuando el proyecto está vinculado directamente al Form.
 */
function createTriggerForActiveForm() {
  try {
    const form = FormApp.getActiveForm();
    ScriptApp.newTrigger('onFormSubmit')
      .forForm(form)
      .onFormSubmit()
      .create();
    console.log(`✅ Trigger creado para el Form activo: ${form.getTitle()}`);
  } catch (error) {
    console.error('❌ Error creando trigger para Form activo:', error);
    throw error;
  }
}
